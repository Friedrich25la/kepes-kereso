<!doctype html>
<html lang="hu">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Termékkereső — Trinexus (külső JSON)</title>
  <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  <script>window.MIN_TOKEN_LEN = window.MIN_TOKEN_LEN || 3;</script>
  <!-- FORCE: use Netlify function for searches (must be BEFORE any script that could fetch the JSON) -->
  <script>window.API_BASE = 'https://aquamarine-cactus-d0f609.netlify.app/.netlify/functions/search';</script>

  <style>
    :root {
      --accent: #33CCBE;
      --bg: #ffffffe9;
      --muted: #666;
      --thumb: 150px;
      --gap: 12px;
      --overlay-height: 38px;
      --max-width: 1200px;
      --card-width: 180px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial;
      margin: 0;
      background: var(--bg);
      color: #111;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .container {
      max-width: var(--max-width);
      margin: 18px auto;
      padding: 18px;
    }

    
    header {
      background: #9b9b9b; /* fehér sáv */
      color: #000;
      padding: 0;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.06);
    }

    .header-wrap {
      max-width: var(--max-width);
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden; 
      padding: 5px 5px;
    }

    
    .text {
      font-weight: 900;
      font-size: 2vw;
      color: #f8f7f7;
      position: relative;
      background-clip: text;
      -webkit-background-clip: text;
      overflow: clip;
      background-color: #fefcef;
      
      padding: 6px 18px;
      z-index: 1; 
      white-space: nowrap;
    }

    
    .text::before,
    .text::after {
      content: '';
      position: absolute;
      
      z-index: -1;

      
      background-color: #199c9c;

      width: 175%;
      top: 50%;
      left: 50%;
      aspect-ratio: 1;
      
      transform: translate(-50%, 0) rotate(0deg);

      border-top-left-radius: 60% 80%;
      border-top-right-radius: 50% 80%;
      border-bottom-left-radius: 50% 80%;
      border-bottom-right-radius: 50% 80%;

      mix-blend-mode: multiply;
      
      animation: rot 10s linear infinite;
      pointer-events: none;
      opacity: 0.95;
    }

    
    .text::after {
      animation-delay: -5s;
      animation-duration: 8s;
    }

    @keyframes rot {
      to {
        
        transform: translate(-50%, 0) rotate(360deg);
      }
    }

    

    
    .toggle {
      display: flex;
      border: 1px solid #e6e6e6;
      border-radius: 10px;
      overflow: hidden;
      width: 420px;
      margin: 18px auto 18px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.03);
    }

    .toggle button {
      flex: 1;
      padding: 12px 14px;
      border: 0;
      background: transparent;
      font-weight: 600;
      cursor: pointer;
    }

    .toggle button.active {
      background: #111;
      color: #fff;
    }

    /* Search / controls */
    .search-row {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 12px;
      justify-content: center;
    }

    .search-row input.search {
      min-width: 320px;
    }

    .search-row .controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .search-row label {
      font-size: 13px;
      color: #333;
    }

    .search-row select,
    input[type=checkbox] {
      padding: 6px;
      border-radius: 6px;
      border: 1px solid #e6e6e6;
    }

    .search-row input[type=checkbox] {
      width: auto;
    }

    .search-row input.search {
      flex: 1;
      padding: 12px 14px;
      border: 1px solid #e6e6e6;
      border-radius: 8px;
      font-size: 16px;
      outline: none;
    }

    /* Results */
    .results {
      display: flex;
      flex-direction: column;
      gap: var(--gap);
      min-height: 120px;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    /* Modified .card so the glow effect can layer correctly */
    .card {
      width: var(--card-width);
      background: #fff;
      border: 1px solid #eee;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
      cursor: pointer;
      text-decoration: none;
      color: inherit;
      transition: transform .14s ease, box-shadow .14s ease;
      position: relative; /* needed for absolute glow child */
      isolation: isolate; /* keep blending contained */
      -webkit-tap-highlight-color: transparent;
    }

    .card:hover {
      transform: scale(1.02);
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.12);
    }

    .card .overlay {
      position: relative;
      z-index: 2; /* ensure overlay content is above glow visuals */
    }

    .card img {
      width: 100%;
      height: var(--thumb);
      object-fit: cover;
      display: block;
      background: #f6f6f6;
    }

    .name-bar {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: var(--overlay-height);
      display: flex;
      align-items: center;
      padding: 6px 8px;
      background: rgba(0, 0, 0, 0.45);
      color: #fff;
      font-size: 12px;
      backdrop-filter: blur(2px);
      z-index: 3;
    }

    .meta {
      padding: 8px 10px;
      border-top: 1px solid #f4f4f4;
      font-size: 13px;
      background: #fff;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      z-index: 2;
    }

    .meta .sku {
      opacity: 0.8;
    }

    .meta .price {
      font-weight: 700;
    }

    .no-results {
      padding: 28px;
      text-align: center;
      color: #666;
    }

    .debug {
      margin-top: 12px;
      padding: 10px;
      background: #f3f3f3;
      border-radius: 6px;
      font-size: 13px;
      color: #333;
      white-space: pre-wrap;
    }

    .loading {
      padding: 10px;
      font-weight: 600;
      color: #0066cc;
    }

    
    .site-header {
      width: 100%;
      background: #8a8989;           /* a szürke sáv színe (állítható) */
      position: relative;            /* a logo abszolút pozícionálásához */
      padding: 8px 0;                /* függőleges padding: sáv magassága */
      box-shadow: 0 2px 6px rgba(0,0,0,0.06);
      overflow: visible;
    }

    
    .logo-link {
      position: absolute;
      left: 12px;                    
      top: 50%;
      transform: translateY(-50%);
      display: inline-block;
      z-index: 5;                    
      text-decoration: none;
    }

    
    .logo {
      height: 44px;
      width: auto;
      display: block;
    }

    
    .header-wrap {
      max-width: var(--max-width, 1200px); /* vagy a te meglévő --max-width változód */
      margin: 0 auto;               /* középre hozza a tartalmat */
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 0 56px;              /* oldalpaddings: biztosít helyet a logó mellett, ne fedje le a szöveget */
      /* ha a logó igazán balra van (left:0), növeld az oldalpaddings-et szükség szerint */
      position: relative;
      z-index: 2;
    }

    
    .text {
      font-weight: 900;
      font-size: 2vw;
      color: #f8f7f7;
      position: relative;
      background-clip: text;
      -webkit-background-clip: text;
      overflow: clip;
      background-color: transparent;  
      padding: 6px 18px;
      z-index: 3;                      
      white-space: nowrap;
    }

    /* Responsive tweaks */
    @media (max-width:480px) {
      :root {
        --thumb: 120px;
      }

      .container {
        padding: 12px;
      }

      .toggle {
        width: 100%;
      }

      .card {
        width: 100%;
      }

      .text {
        font-size: 5.2vw;
      }
    }

    @media (min-width:900px) {
      /* at wide view ensure card width is as set, more columns fit automatically */
    }

    @media (max-width:480px) {
      .logo {
        height: 20px;
      }
      .header-wrap {
        padding: 0 12px;
      }
      .text {
        font-size: 5.5vw;
        white-space: normal;
        text-align: center;
      }
    }



    
    :root {
      /* variables for the glow effect - do not conflict with existing --card-width etc */
      --glow-backdrop: hsl(0 0% 60% / 0.12);
      --radius: 14;
      --border: 3;
      --backup-border: var(--glow-backdrop);
      --size: 200;
    }

    /* We scope the heavy selectors to cards that have data-glow attribute */
    [data-glow] {
      --border-size: calc(var(--border, 2) * 1px);
      --spotlight-size: calc(var(--size, 150) * 1px);
      --hue: calc(var(--base, 190) + (var(--xp, 0) * var(--spread, 0)));
      background-image: radial-gradient(
        var(--spotlight-size) var(--spotlight-size) at
        calc(var(--x, 0) * 1px)
        calc(var(--y, 0) * 1px),
        hsl(var(--hue, 210) calc(var(--saturation, 100) * 1%) calc(var(--lightness, 70) * 1%) / var(--bg-spot-opacity, 0.1)), transparent
      );
      background-color: var(--glow-backdrop, transparent);
      background-size: calc(100% + (2 * var(--border-size))) calc(100% + (2 * var(--border-size)));
      background-position: 50% 50%;
      background-attachment: fixed;
      border: var(--border-size) solid var(--backup-border);
      position: relative;
      touch-action: none;
      border-radius: calc(var(--radius) * 1px);
      z-index: 1;
      overflow: visible;
    }

    [data-glow]::before,
    [data-glow]::after {
      pointer-events: none;
      content: "";
      position: absolute;
      inset: calc(var(--border-size) * -1);
      border: var(--border-size) solid transparent;
      border-radius: calc(var(--radius) * 1px);
      background-attachment: fixed;
      background-size: calc(100% + (2 * var(--border-size))) calc(100% + (2 * var(--border-size)));
      background-repeat: no-repeat;
      background-position: 50% 50%;
      mask:
        linear-gradient(transparent, transparent),
        linear-gradient(white, white);
      mask-clip: padding-box, border-box;
      mask-composite: intersect;
    }

    [data-glow]::before {
      background-image: radial-gradient(
        calc(var(--spotlight-size) * 0.75) calc(var(--spotlight-size) * 0.75) at
        calc(var(--x, 0) * 1px)
        calc(var(--y, 0) * 1px),
        hsl(var(--hue, 210) calc(var(--saturation, 100) * 1%) calc(var(--lightness, 50) * 1%) / var(--border-spot-opacity, 1)), transparent 100%
      );
      filter: brightness(2);
      z-index: 0;
    }

    [data-glow]::after {
      background-image: radial-gradient(
        calc(var(--spotlight-size) * 0.5) calc(var(--spotlight-size) * 0.5) at
        calc(var(--x, 0) * 1px)
        calc(var(--y, 0) * 1px),
        hsl(var(--hue,210) calc(var(--saturation,100) * 1%) calc(92 * 1%) / var(--border-light-opacity, 0.85)), transparent 100%
      );
    }


    /* nested glow element (empty element used for blur/outer glow layer) */
    [data-glow] [data-glow] {
      position: absolute;
      inset: 0;
      will-change: filter;
      opacity: var(--outer, 1);
      border-radius: calc(var(--radius) * 1px);
      z-index: 0;
      pointer-events: none;
    }
    [data-glow] > [data-glow] {
      border-radius: calc(var(--radius) * 1px);
      border-width: calc(var(--border-size) * 20);
      filter: blur(calc(var(--border-size) * 10));
      background: none;
      pointer-events: none;
    }
    [data-glow] > [data-glow]::before {
      inset: -10px;
      border-width: 10px;
    }
    [data-glow] [data-glow] {
      border: none;
    }

    [data-glow] :is(a, button) {
      border-radius: calc(var(--radius) * 1px);
      border: var(--border-size) solid transparent;
    }

    /* small safety: ensure internal overlay content sits above glow visuals */
    .card > .overlay,
    .card > .meta {
      position: relative;
      z-index: 2;
    }

    /* tweak highlight strength for light background */
    @media (prefers-color-scheme: light) {
      [data-glow] { --bg-spot-opacity: 0.06; --border-spot-opacity: 0.8; --border-light-opacity: 0.6; }
    }

    /* End glow CSS */

    /* -------------------- Strong preset overrides (fehér háttérre) -------------------- */
    :root {
      --bg-spot-opacity: 0.9;       /* háttér folt intenzitása */
      --border-spot-opacity: 1.5;      /* kontúr színes folt erőssége */
      --border-light-opacity: 0.35;     /* fehér szikra intenzitása */
      --size: 90;                   /* spot méret (px) — kisebb = élesebb) */
      --border: 9;                   /* keret vastagság */
      --saturation: 140;
      --lightness: 60;
    }
    
    @media (max-width: 800px) {
      [data-glow] {
        touch-action: auto !important;        /* engedjük az érintéses görgetést */
        background-image: none !important;    /* eltávolítjuk a spot-ot */
        background-color: transparent !important;
        border: none !important;
        background-attachment: scroll !important;
      }
      [data-glow]::before,
      [data-glow]::after,
      [data-glow] [data-glow],
      [data-glow] > [data-glow] {
        display: none !important;             /* elrejti a pseudo / blur rétegeket */
      }
    }

  </style>
  <script>
    // Állítsd be ide a Netlify site-od pontos domainjét (például: aquamarine-cactus-d0f609):
    window.API_BASE = 'https://aquamarine-cactus-d0f609.netlify.app/.netlify/functions/search';
    // Alternatíva (ha a frontend ugyanazon a Netlify site-on van): window.API_BASE = window.API_BASE || '/.netlify/functions/search';
  </script>

  

  
</head>

<body>
  <header class="site-header">
    <a href="https://www.trinexus.hu" target="_blank" class="logo-link" aria-label="Trinexus főoldal">
      <img src="logo2.png" alt="Trinexus Aqua" class="logo">
    </a>
  
    <div class="header-wrap">
      <div class="text">Trinexus Aqua képes termékkereső</div>
    </div>
  </header>


  <div class="container">
    <div class="toggle" role="tablist" aria-label="Kereső mód">
      <button id="prodBtn" class="active">Termékkereső</button>
      <button id="catBtn">Kategóriakereső</button>
    </div>

    <div class="search-row">
      <input id="q" class="search" type="search" placeholder="Írja be a termék nevét vagy cikkszámát..."
        autocomplete="off" disabled />
    </div>

    <div style="display:flex;gap:12px;align-items:center;justify-content:center;margin-bottom:12px;">
      <label for="sortSelect">Rendezés:</label>
      <select id="sortSelect" aria-label="Rendezés">
        <option value="relevance">Relevancia</option>
        <option value="price_asc">Ár: növekvő</option>
        <option value="price_desc">Ár: csökkenő</option>
        <option value="name_asc">Név A→Z</option>
        <option value="name_desc">Név Z→A</option>
      </select>
      <label style="margin-left:12px"><input type="checkbox" id="imgOnly"> csak képpel rendelkező termékek</label>
    </div>

    <div id="results" class="results">
      <div class="loading"></div>
    </div>

    <div id="debug" class="debug" aria-live="polite" style="display:none"></div>
  </div>

  <script id="products-data" type="application/json"></script>

  <script>
  (function initProductsNoFallback(){
    if (window.API_BASE && window.API_BASE.length) {
      window.USE_API = true;
      var qEl = document.getElementById('q');
      if (qEl) { qEl.disabled = false; qEl.placeholder = 'Írja be a termék nevét vagy cikkszámát...'; }
      var results = document.getElementById('results');
      if (results && (!results.querySelector('.row'))) results.innerHTML = '<div class="no-results">Írjon legalább ' + MIN_TOKEN_LEN + ' karaktert a találatok megjelenítéséhez.</div>';
      return;
    }
    // Ha ide jutsz, nincs API beállítva: jelezz hibát a debug mezőben
    try {
      var dbg = document.getElementById('debug');
      if (dbg) dbg.style.display = 'block', dbg.textContent = 'Nincs elérhető termékforrás (API nincs beállítva).';
    } catch (e){}
  })();
  </script>


  <!--  ======= -->
  <script>
    /* ---------- Config ---------- */
    const GLOBAL_MAX_RESULTS = 500; // megjeleníthető találatok felső korlátja
    const MIN_TOKEN_LEN = 3;

    /* ---------- Data + preprocessing ---------- */
    let PRODUCTS = [];

    function stripDiacriticsSimple(s) {
      if (!s) return '';
      var map = { 'á': 'a', 'Á': 'A', 'é': 'e', 'É': 'E', 'í': 'i', 'Í': 'I', 'ó': 'o', 'Ó': 'O', 'ö': 'o', 'Ö': 'O', 'ő': 'o', 'Ő': 'O', 'ú': 'u', 'Ú': 'U', 'ü': 'u', 'Ü': 'U', 'ű': 'u', 'Ű': 'U' };
      return s.replace(/[ÁáÉéÍíÓóÖöŐőÚúÜüŰű]/g, function (ch) { return map[ch] || ch; });
    }

    function preprocessProducts() {
      for (var i = 0; i < PRODUCTS.length; i++) {
        var p = PRODUCTS[i];
        var name = p.name || '';
        var sku = p.sku || '';
        try {
          var n = name.toString();
          n = stripDiacriticsSimple(n);
          n = n.normalize ? n.normalize('NFD').replace(/[̀-ͯ]/g, '') : n;
          p.__norm_name = n.toLowerCase().replace(/[^a-z0-9À-ſ]+/gi, ' ').trim();
        } catch (e) { p.__norm_name = (name + '').toLowerCase(); }
        try {
          var s = sku.toString();
          s = stripDiacriticsSimple(s);
          s = s.normalize ? s.normalize('NFD').replace(/[̀-ͯ]/g, '') : s;
          p.__norm_sku = s.toLowerCase().replace(/[^a-z0-9]+/gi, '').trim();
        } catch (e) { p.__norm_sku = (sku + '').toLowerCase(); }
        p.__name_words = (p.__norm_name || '').split(/\s+/).filter(Boolean);
        p.__status = (typeof p.status !== 'undefined') ? ((p.status === '0' || p.status === 0) ? 0 : Number(p.status) || 1) : null;
      }
    }

    /* ---------- Parse embedded JSON if present in placeholder ---------- */
    (function parsePlaceholderIfPresent() {
      try {
        var rawScript = document.getElementById('products-data');
        if (rawScript) {
          var raw = rawScript.textContent || '';
          if (raw && raw.trim().length > 10) {
            // Próbáljuk egyszerűen parse-olni először
            try {
              PRODUCTS = JSON.parse(raw);
            } catch (err1) {
              // Ha valami miatt a sima parse sikertelen (különös escape-ok), próbáljunk egy biztonságosabb string-cserét
              try {
                // string-split/join használata biztonságosabb, mintha regex literált hagynánk,
                // mert néha valami közbeavatkozik és a /.../g felsértődhet a futtatási környezetben
                var safe = raw.split('\\/').join('/');
                PRODUCTS = JSON.parse(safe);
              } catch (err2) {
                console.error('AUTO-INIT parse error (both attempts):', err2);
                // tovább dobhatjuk, vagy a debug mezőbe írjuk az üzenetet:
                var dbg = document.getElementById('debug');
                if (dbg) { dbg.style.display = 'block'; dbg.textContent = 'AUTO-INIT parse error: ' + (err2 && err2.toString ? err2.toString() : 'ismeretlen'); }
              }
            }
          }

        }
        if (PRODUCTS && PRODUCTS.length > 0) {
          preprocessProducts();
          var debugEl = document.getElementById('debug');
          if (debugEl) { debugEl.style.display = 'block'; debugEl.textContent = ''; }
          var qEl = document.getElementById('q');
          if (qEl) { qEl.disabled = false; qEl.placeholder = 'Írja be a termék nevét vagy cikkszámát...'; }
          var results = document.getElementById('results');
          if (results && (!results.querySelector('.row'))) results.innerHTML = '<div class="no-results">Írjon legalább ' + MIN_TOKEN_LEN + ' karaktert a találatok megjelenítéséhez.</div>';
        } else {
          var dbg = document.getElementById('debug');
          if (dbg) { dbg.style.display = 'block'; dbg.textContent = 'Nincsenek beágyazott termékek — a külső JSON tölthető be.'; }
        }
      } catch (e) {
        console.error('JSON parse error', e);
        var dbg = document.getElementById('debug'); if (dbg) { dbg.style.display = 'block'; dbg.textContent = 'JSON parse error: ' + (e && e.toString ? e.toString() : 'ismeretlen'); }
      }
    })();

    /* ---------- Matching logic (exact old algorithm) ---------- */
    function matches(product, q) {
        if (!q) return false;
        var nq = q.toString().trim();
        if (nq.length < MIN_TOKEN_LEN) return false;

        // egyszerű normalizálás
        try {
          nq = stripDiacriticsSimple(nq);
          nq = nq.normalize ? nq.normalize('NFD').replace(/[̀-ͯ]/g, '') : nq;
        } catch (e) { }
        nq = nq.toLowerCase();

        // felhasználó által beírt szavak
        var tokens = nq.split(/\s+/).map(function (t) { return t.trim(); }).filter(Boolean);
        if (tokens.length === 0) return false;

        // termék adatok normalizálva
        var name = product.__norm_name || ((product.name || '').toString().toLowerCase());
        var sku = product.__norm_sku || (product.sku || '').toString().toLowerCase();

        // minden tokennek szerepelnie kell legalább a névben vagy cikkszámban
        var allFound = tokens.every(function (tk) {
          if (tk.length < MIN_TOKEN_LEN) return false;
          return (
            name.indexOf(tk) !== -1 ||
            sku.indexOf(tk.replace(/[^a-z0-9]+/g, '')) !== -1
          );
        });

        return allFound;
      }


    /* ---------- Utilities ---------- */
    function formatPrice(raw) {
      var n = Number(raw);
      if (isFinite(n)) {
        var fmt = Math.round(n).toLocaleString('hu-HU').replace(/\u00A0/g, ' ');
        return fmt + ' Ft';
      }
      return raw || '';
    }

    function splitImageList(imgField) {
      if (!imgField) return [];
      return imgField.toString().split(/\||,|;|\n/).map(function (x) { return x.trim(); }).filter(Boolean);
    }

    /* ---------- Rendering ---------- */
    function renderProductsList(list) {
      var results = document.getElementById('results');
      results.innerHTML = '';
      if (!list || list.length === 0) {
        results.innerHTML = '<div class="no-results">Nincs találat.</div>';
        return;
      }

      // create row flex container
      var row = document.createElement('div');
      row.className = 'row';

      for (var i = 0; i < list.length; i++) {
        var p = list[i];
        var a = document.createElement('a');
        a.className = 'card';
        a.href = p.url || '#';
        a.target = '_blank';
        a.rel = 'noopener noreferrer';

        // add data-glow attribute so the glow CSS applies
        a.setAttribute('data-glow', '');

        // nested empty data-glow element used for blur/outer glow layer (per CSS)
        var innerGlow = document.createElement('div');
        innerGlow.setAttribute('data-glow', '');
        // ensure the inner glow sits behind content via z-index in CSS
        a.appendChild(innerGlow);

        var overlay = document.createElement('div');
        overlay.className = 'overlay';

        var img = document.createElement('img');
        img.loading = 'lazy';
        img.alt = p.name || p.sku || '';
        var imgs = splitImageList(p.img || '');
        img._trying = 0;
        img.src = imgs.length ? (imgs[0].indexOf('http') === 0 ? imgs[0] : ('https://' + imgs[0])) : 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
        // onerror fallback
        img.onerror = (function (__imgs) {
          return function () {
            try {
              if (this._trying < __imgs.length - 1) { this._trying++; this.src = __imgs[this._trying]; return; }
              var cur = this.src || '';
              if (cur.indexOf('http://') === 0) { this.src = cur.replace('http://', 'https://'); return; }
              if (cur.indexOf('https://') === 0) { this.src = cur.replace('https://', 'http://'); return; }
            } catch (e) { }
            this.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
          };
        })(imgs);

        overlay.appendChild(img);

        var nameBar = document.createElement('div');
        nameBar.className = 'name-bar';
        nameBar.textContent = p.name || '—';
        overlay.appendChild(nameBar);

        var meta = document.createElement('div');
        meta.className = 'meta';
        var skuSpan = document.createElement('span'); skuSpan.className = 'sku'; skuSpan.textContent = p.sku || '';
        var priceSpan = document.createElement('span'); priceSpan.className = 'price';
        (function () { var raw = p.price || ''; var n = Number(raw); if (isFinite(n) && n !== 0) { var fmt = Math.round(n).toLocaleString('hu-HU').replace(/\u00A0/g, ' '); priceSpan.textContent = fmt + ' Ft'; } else { priceSpan.textContent = (n === 0 ? '0 Ft' : (raw || '')); } })();
        meta.appendChild(skuSpan); meta.appendChild(priceSpan);

        a.appendChild(overlay);
        a.appendChild(meta);
        row.appendChild(a);
      }

      results.appendChild(row);
      // after rendering, attach pointer handlers so glow follows per-card
      if (window.attachCardPointer) {
        setTimeout(window.attachCardPointer, 30);
      }
    }

    /* ---------- ÁLLAPOTKEZELÉS ---------- */
      let currentState = {
        query: '',
        page: 1,
        isLoading: false,
        hasMore: true
      };

      /* ---------- API HÍVÁS ---------- */
      async function fetchProducts(query, page) {
        // 50-esével kérjük le, így gyors marad
        const limit = 50;
        const params = new URLSearchParams({ q: query, page: page, limit: limit });

        const response = await fetch(`${window.API_BASE}?${params.toString()}`);
        if (!response.ok) throw new Error('Hálózati hiba');
        return await response.json();
      }

      /* ---------- KERESÉS INDÍTÁSA (Rendezéssel + Képszűréssel) ---------- */
    async function renderForQuery(q) {
        const resultsEl = document.getElementById('results');
        const debugEl = document.getElementById('debug');
        
        // 1. Validálás
        if (!q || q.trim().length < MIN_TOKEN_LEN) {
            resultsEl.innerHTML = '<div class="no-results">Írjon legalább ' + MIN_TOKEN_LEN + ' karaktert.</div>';
            removeLoadMoreButton();
            return;
        }

        // 2. Állapot reset (csak ha ez egy teljesen új keresés, nem lapozás)
        // Megjegyzés: Ezt a függvényt hívja a gépelés, tehát ez mindig új keresés.
        currentState.query = q.trim();
        currentState.page = 1;
        currentState.hasMore = true;
        
        resultsEl.innerHTML = '<div class="loading">Keresés...</div>';
        removeLoadMoreButton();

        try {
            // 3. Adatok letöltése a szerverről
            const data = await fetchProducts(currentState.query, currentState.page);
            
            if (debugEl) {
                debugEl.style.display = 'block';
                debugEl.textContent = `Összes találat: ${data.total_count}`;
            }

            if (data.results.length === 0) {
                resultsEl.innerHTML = '<div class="no-results">Nincs találat.</div>';
                return;
            }

            // 4. ELŐKÉSZÍTÉS (Töröljük az előző tartalmat)
            resultsEl.innerHTML = ''; 
            let list = data.results;

            // ---------------------------------------------------------
            // A) SZŰRÉS: Csak képpel rendelkező termékek (EZ HIÁNYZOTT)
            // ---------------------------------------------------------
            const imgOnly = document.getElementById('imgOnly') && document.getElementById('imgOnly').checked;
            if (imgOnly) {
                // Csak azokat hagyjuk meg, ahol az 'img' mező létezik és nem üres
                list = list.filter(p => p.img && p.img.length > 0);
            }

            // Ha a szűrés után elfogyott minden elem az oldalról
            if (list.length === 0 && data.total_count > 0) {
                resultsEl.innerHTML = '<div class="no-results">Ezen az oldalon nincsenek képpel rendelkező termékek. Próbáljon lapozni.</div>';
            }

            // ---------------------------------------------------------
            // B) RENDEZÉS: A felhasználó választása szerint
            // ---------------------------------------------------------
            const sortVal = document.getElementById('sortSelect') ? document.getElementById('sortSelect').value : 'relevance';
            
            if (sortVal !== 'relevance') {
                list.sort((a, b) => {
                    if (sortVal.includes('price')) {
                        const na = Number(a.price) || 0;
                        const nb = Number(b.price) || 0;
                        return sortVal === 'price_asc' ? (na - nb) : (nb - na);
                    }
                    if (sortVal.includes('name')) {
                        const na = (a.name || '').toLowerCase();
                        const nb = (b.name || '').toLowerCase();
                        return sortVal === 'name_asc' ? na.localeCompare(nb) : nb.localeCompare(na);
                    }
                    return 0;
                });
            }

            // 5. MEGJELENÍTÉS
            appendResults(list);

            // Gomb kezelése: Ha van még több adat a szerveren, kirakjuk a gombot
            if (data.total_count > (currentState.page * data.limit)) {
                createLoadMoreButton();
            }

        } catch (err) {
            console.error(err);
            resultsEl.innerHTML = '<div class="no-results">Hiba történt: ' + err.message + '</div>';
        }
    }

      /* ---------- TÖBB BETÖLTÉSE (Load More) ---------- */
      async function loadMore() {
        if (currentState.isLoading || !currentState.hasMore) return;

        const btn = document.getElementById('loadMoreBtn');
        if (btn) btn.textContent = 'Betöltés...';
        currentState.isLoading = true;

        try {
          currentState.page++;
          const data = await fetchProducts(currentState.query, currentState.page);

          appendResults(data.results);

          if (data.total_count <= (currentState.page * data.limit)) {
            currentState.hasMore = false;
            removeLoadMoreButton();
          } else {
            if (btn) btn.textContent = 'További találatok betöltése';
          }
        } catch (err) {
          console.error(err);
          if (btn) btn.textContent = 'Hiba a betöltéskor (próbáld újra)';
        } finally {
          currentState.isLoading = false;
        }
      }

      /* ---------- SEGÉDFÜGGVÉNYEK ---------- */

      // Ez a meglévő renderProductsList-et hívja, de okosabban
      function appendResults(list) {
        // Kliens oldali szűrés (pl. csak képpel), ha be van pipálva
        const imgOnly = document.getElementById('imgOnly') && document.getElementById('imgOnly').checked;
        let filtered = list;
        if (imgOnly) {
          filtered = list.filter(p => p.img && p.img.length > 0);
        }

        // Mivel a renderProductsList felülírja a results tartalmát, 
        // nekünk appendelni kell. Ehhez trükközünk kicsit, vagy átírjuk a render-t.
        // A legegyszerűbb, ha a meglévő "row" div-be fűzzük be, vagy újat csinálunk.

        const resultsEl = document.getElementById('results');
        let row = resultsEl.querySelector('.row');
        if (!row) {
          row = document.createElement('div');
          row.className = 'row';
          resultsEl.appendChild(row);
        }

        // Itt újrahasznosítjuk a meglévő kártya-generáló logikát a renderProductsList-ből,
        // de mivel az törli a tartalmat, jobb ha manuálisan generáljuk a kártyákat ide.
        // (Vagy módosítjuk a renderProductsList-et, hogy ne töröljön).

        // MÓDOSÍTÁS: Ideiglenesen használjuk a fenti HTML struktúrát generáló kódot:
        list.forEach(p => {
          // Ez a kód gyakorlatilag ugyanaz, mint a te eredeti renderProductsList függvényed magja
          const a = document.createElement('a');
          a.className = 'card';
          a.href = p.url || '#';
          a.target = '_blank';
          a.setAttribute('data-glow', '');

          // Glow inner
          const innerGlow = document.createElement('div');
          innerGlow.setAttribute('data-glow', '');
          a.appendChild(innerGlow);

          const overlay = document.createElement('div');
          overlay.className = 'overlay';

          const img = document.createElement('img');
          img.loading = 'lazy';
          // Képkezelés (most már jön az API-ból a p.img!)
          const imgs = (p.img || '').toString().split(/\||,|;|\n/).filter(Boolean);
          img.src = imgs.length ? (imgs[0].startsWith('http') ? imgs[0] : 'https://' + imgs[0]) : 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';

          overlay.appendChild(img);

          const nameBar = document.createElement('div');
          nameBar.className = 'name-bar';
          nameBar.textContent = p.name || '-';
          overlay.appendChild(nameBar);

          const meta = document.createElement('div');
          meta.className = 'meta';
          meta.innerHTML = `<span class="sku">${p.sku || ''}</span><span class="price">${p.price ? Math.round(p.price).toLocaleString('hu-HU') + ' Ft' : ''}</span>`;

          a.appendChild(overlay);
          a.appendChild(meta);

          row.appendChild(a);
        });

        // Glow effekt újraaktiválása az új elemeken
        if (window.attachCardPointer) window.attachCardPointer();
      }

      function createLoadMoreButton() {
        removeLoadMoreButton(); // Biztos ami biztos
        const btnContainer = document.createElement('div');
        btnContainer.id = 'loadMoreContainer';
        btnContainer.style.textAlign = 'center';
        btnContainer.style.padding = '20px';

        const btn = document.createElement('button');
        btn.id = 'loadMoreBtn';
        btn.textContent = 'További találatok betöltése';
        btn.style.padding = '10px 20px';
        btn.style.fontSize = '16px';
        btn.style.cursor = 'pointer';
        btn.onclick = loadMore;

        btnContainer.appendChild(btn);
        document.getElementById('results').parentNode.insertBefore(btnContainer, document.getElementById('results').nextSibling);
      }

      function removeLoadMoreButton() {
        const el = document.getElementById('loadMoreContainer');
        if (el) el.remove();
      }

      /* ---------- EVENT LISTENERS ---------- */
      (function wireEvents() {
        var qInput = document.getElementById('q');
        var timer = null;
        if (qInput) {
          qInput.addEventListener('input', function (e) {
            clearTimeout(timer);
            timer = setTimeout(function () { renderForQuery(e.target.value); }, 500);
          });
        }
      })();

    /* ---------- Auto-init when external JSON loaded ---------- */
    (function autoInit() {
      function finishInit() {
        try {
          if (window.__EMBEDDED_PRODUCTS && Array.isArray(window.__EMBEDDED_PRODUCTS)) {
            PRODUCTS = window.__EMBEDDED_PRODUCTS.slice();
          } else {
            var raw = (document.getElementById('products-data') || { textContent: '' }).textContent || '';
            if (raw && raw.trim().length > 10) {
              try { PRODUCTS = JSON.parse(raw); } catch (e) { console.error('AUTO-INIT parse error', e); }
            }
          }
          if (PRODUCTS && PRODUCTS.length > 0) {
            preprocessProducts();
            // enable search input
            var qEl = document.getElementById('q');
            if (qEl) { qEl.disabled = false; qEl.placeholder = 'Írja be a termék nevét vagy cikkszámát...'; }
            console.log('AUTO-INIT: PRODUCTS=', PRODUCTS.length);
          }
        } catch (e) { console.error('AUTO-INIT error', e); }
      }

      document.addEventListener('productsDataReady', function () { finishInit(); }, { once: true });
      // fallback attempt after short delay
      setTimeout(finishInit, 1500);
    })();
  </script>

  <!-- small navigation wiring -->
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      try {
        var prodBtn = document.getElementById('prodBtn');
        var catBtn = document.getElementById('catBtn');
        function setActive(isProd) { if (isProd) { prodBtn.classList.add('active'); catBtn.classList.remove('active'); } else { prodBtn.classList.remove('active'); catBtn.classList.add('active'); } }
        setActive(true);
        if (prodBtn) prodBtn.addEventListener('click', function (e) { e.preventDefault(); setActive(true); });
        if (catBtn) catBtn.addEventListener('click', function (e) { e.preventDefault(); window.location.href = 'kepes_kereso_site.html'; });
      } catch (e) { console.error(e) }
    });
  </script>

  <!-- ---------- Per-card Pointer sync script for glow (from modified JS snippet) ---------- -->
  <script>
    function attachCardPointer() {
      const cards = Array.from(document.querySelectorAll('.card[data-glow]'));
      if (!cards.length) return;

      cards.forEach(card => {
        if (card._glowPointerAttached) return;
        card._glowPointerAttached = true;

        // We'll track a single handler reference for attach/detach
        let onMove = (ev) => {
          const rect = card.getBoundingClientRect();
          const x = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
          const y = Math.max(0, Math.min(rect.height, ev.clientY - rect.top));
          card.style.setProperty('--x', x.toFixed(2));
          card.style.setProperty('--xp', (x / rect.width).toFixed(3));
          card.style.setProperty('--y', y.toFixed(2));
          card.style.setProperty('--yp', (y / rect.height).toFixed(3));
        };

        const onEnter = (e) => {
          document.addEventListener('pointermove', onMove, { passive: true });
          onMove(e);
          card.classList.add('glow-active');
        };

        const onLeave = (e) => {
          document.removeEventListener('pointermove', onMove);
          card.classList.remove('glow-active');
        };

        const onPointerDown = (e) => {
          document.addEventListener('pointermove', onMove, { passive: true });
          onMove(e);
        };
        const onPointerUp = (e) => {
          document.removeEventListener('pointermove', onMove);
        };

        card.addEventListener('pointerenter', onEnter);
        card.addEventListener('pointerleave', onLeave);
        card.addEventListener('pointerdown', onPointerDown, { passive: true });
        document.addEventListener('pointerup', onPointerUp, { passive: true });

        card.addEventListener('focus', (e) => {
          const rect = card.getBoundingClientRect();
          const cx = rect.width / 2, cy = rect.height / 2;
          card.style.setProperty('--x', cx.toFixed(2));
          card.style.setProperty('--xp', (cx / rect.width).toFixed(3));
          card.style.setProperty('--y', cy.toFixed(2));
          card.style.setProperty('--yp', (cy / rect.height).toFixed(3));
        });
      });
    }

    document.addEventListener('DOMContentLoaded', function () {
      attachCardPointer();
    });

    // Wrap existing renderProductsList so newly rendered cards reattach pointers
    if (typeof window.renderProductsList === 'function') {
      const _orig = window.renderProductsList.bind(window);
      window.renderProductsList = function (list) {
        _orig(list);
        setTimeout(attachCardPointer, 40);
      };
    } else {
      window.attachCardPointer = attachCardPointer;
    }
  </script>
  <footer style="font-size:13px;color:#666;padding:16px;text-align:center">
    © 2025 MagicR Minden jog fenntartva.
  </footer>


</body>

</html>
